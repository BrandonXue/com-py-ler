Token: Separator    Lexeme: $$
    <Rat20SU> -> $$ <Opt Declaration List> <Statement List> $$
Token: Keyword      Lexeme: integer
    <Opt Declaration List> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: one_constant
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: zero_constant
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: i
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: n
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: prev
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: temp
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: integer
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> integer
Token: Identifier   Lexeme: root
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: boolean
    <Declaration List Split> -> <Declaration List>
    <Declaration List> -> <Declaration> ; <Declaration List Split>
    <Declaration> -> <Qualifier> <Identifier>
    <Qualifier> -> boolean
Token: Identifier   Lexeme: loop
Token: Separator    Lexeme: ;
Token: Identifier   Lexeme: one_constant
    <Declaration List Split> -> epsilon
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Integer      Lexeme: 1
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: zero_constant
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: get
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Get>
    <Get> -> get ( <Identifier> ) ;
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: n
Token: Separator    Lexeme: )
Token: Separator    Lexeme: ;
Token: Identifier   Lexeme: prev
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: n
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: i
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: loop
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Keyword      Lexeme: true
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> true
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: while
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <While>
    <While> -> while ( <Condition> ) <Statement>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: loop
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: ==
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> ==
Token: Keyword      Lexeme: true
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> true
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: {
    <Statement> -> <Compound>
    <Compound> -> { <Statement List> }
Token: Identifier   Lexeme: temp
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: *
    <Term Prime> -> * <Factor> <Term Prime>
Token: Identifier   Lexeme: i
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: if
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> <If Split>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: n
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: >
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> >
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: temp
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: n
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: -
    <Term Prime> -> epsilon
    <Expression Prime> -> - <Term> <Expression Prime>
Token: Identifier   Lexeme: temp
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: otherwise
    <If Split> -> otherwise <Statement> fi
Token: Identifier   Lexeme: temp
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: -
    <Term Prime> -> epsilon
    <Expression Prime> -> - <Term> <Expression Prime>
Token: Identifier   Lexeme: n
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: fi
Token: Keyword      Lexeme: if
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> <If Split>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: >
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> >
Token: Identifier   Lexeme: prev
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: {
    <Statement> -> <Compound>
    <Compound> -> { <Statement List> }
Token: Identifier   Lexeme: loop
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: False
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: i
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: -
    <Term Prime> -> epsilon
    <Expression Prime> -> - <Term> <Expression Prime>
Token: Integer      Lexeme: 1
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: }
    <Statement List Split> -> epsilon
Token: Keyword      Lexeme: otherwise
    <If Split> -> otherwise <Statement> fi
Token: Separator    Lexeme: {
    <Statement> -> <Compound>
    <Compound> -> { <Statement List> }
Token: Identifier   Lexeme: prev
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: i
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: +
    <Term Prime> -> epsilon
    <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer      Lexeme: 1
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: }
    <Statement List Split> -> epsilon
Token: Keyword      Lexeme: fi
Token: Separator    Lexeme: }
    <Statement List Split> -> epsilon
Token: Identifier   Lexeme: root
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: temp
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: i
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: while
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <While>
    <While> -> while ( <Condition> ) <Statement>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: root
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: >
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> >
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: {
    <Statement> -> <Compound>
    <Compound> -> { <Statement List> }
Token: Identifier   Lexeme: prev
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: root
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: root
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: root
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: /
    <Term Prime> -> / <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: if
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> <If Split>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: root
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: *
    <Term Prime> -> * <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Operator     Lexeme: ==
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> ==
Token: Identifier   Lexeme: prev
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: root
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: root
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: otherwise
    <If Split> -> otherwise <Statement> fi
Token: Identifier   Lexeme: temp
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: +
    <Term Prime> -> epsilon
    <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer      Lexeme: 1
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: fi
Token: Identifier   Lexeme: temp
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: *
    <Term Prime> -> * <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Identifier   Lexeme: i
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: +
    <Term Prime> -> epsilon
    <Expression Prime> -> + <Term> <Expression Prime>
Token: Integer      Lexeme: 1
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: }
    <Statement List Split> -> epsilon
Token: Identifier   Lexeme: temp
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: /
    <Term Prime> -> / <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: while
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <While>
    <While> -> while ( <Condition> ) <Statement>
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: >
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> >
Token: Integer      Lexeme: 0
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: {
    <Statement> -> <Compound>
    <Compound> -> { <Statement List> }
Token: Identifier   Lexeme: i
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: i
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: -
    <Term Prime> -> epsilon
    <Expression Prime> -> - <Term> <Expression Prime>
Token: Integer      Lexeme: 1
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: if
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <If>
    <If> -> if ( <Condition> ) <Statement> <If Split>
Token: Separator    Lexeme: (
Token: Separator    Lexeme: (
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> ( <Expression> )
Token: Separator    Lexeme: (
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> ( <Expression> )
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: /
    <Term Prime> -> / <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Operator     Lexeme: *
    <Term Prime> -> * <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Operator     Lexeme: ==
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
    <Relop> -> ==
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Separator    Lexeme: )
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Keyword      Lexeme: put
    <Statement> -> <Put>
    <Put> -> put ( <Identifier> ) ;
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: one_constant
Token: Separator    Lexeme: )
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: otherwise
    <If Split> -> otherwise <Statement> fi
Token: Keyword      Lexeme: put
    <Statement> -> <Put>
    <Put> -> put ( <Identifier> ) ;
Token: Separator    Lexeme: (
Token: Identifier   Lexeme: zero_constant
Token: Separator    Lexeme: )
Token: Separator    Lexeme: ;
Token: Keyword      Lexeme: fi
Token: Identifier   Lexeme: temp
    <Statement List Split> -> <Statement List>
    <Statement List> -> <Statement> <Statement List Split>
    <Statement> -> <Assign>
    <Assign> -> <Identifier> = <Expression> ;
Token: Operator     Lexeme: =
Token: Identifier   Lexeme: temp
    <Expression> -> <Term> <Expression Prime>
    <Term> -> <Factor> <Term Prime>
    <Factor> -> <Primary>
    <Primary> -> <Identifier>
Token: Operator     Lexeme: /
    <Term Prime> -> / <Factor> <Term Prime>
Token: Integer      Lexeme: 2
    <Factor> -> <Primary>
    <Primary> -> <Integer>
Token: Separator    Lexeme: ;
    <Term Prime> -> epsilon
    <Expression Prime> -> epsilon
Token: Separator    Lexeme: }
    <Statement List Split> -> epsilon
Token: Separator    Lexeme: $$
    <Statement List Split> -> epsilon
    
Rat20SU Accepted
